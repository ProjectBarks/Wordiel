package wordielv2.generator;

import java.awt.Font;
import java.awt.Shape;
import java.awt.font.FontRenderContext;
import java.awt.font.GlyphVector;
import java.awt.geom.AffineTransform;
import java.text.Bidi;
import lombok.Getter;
import lombok.Setter;

/**
 *
 * @author 17bbarker
 */
public class Word implements Comparable<Word>, Cloneable {

    private static final FontRenderContext FRC = new FontRenderContext(null, true, true);

    public Shape generateShape(String word, Font font, double weight) {
        final Font sizedFont = font.deriveFont((float) weight);
        final char[] chars = word.toCharArray();
        final int direction = Bidi.requiresBidi(chars, 0, chars.length)
                              ? Font.LAYOUT_RIGHT_TO_LEFT : Font.LAYOUT_LEFT_TO_RIGHT;
        final GlyphVector gv =
                          sizedFont.layoutGlyphVector(FRC, chars, 0, chars.length, direction);
        Shape result = gv.getOutline();
        if (orientation != 0.0) {
            result = AffineTransform.getRotateInstance(orientation).createTransformedShape(result);
        }
        return result;
    }
    @Getter
    private final String word;
    @Getter
    @Setter
    private double weight, orientation;
    @Getter
    private Shape shape;
    @Getter
    private Font font;
    @Getter
    @Setter
    private Vector location;
    private Shape templateShape;
    protected BBTree bbTree;
    private int swelling;

    public Word(String word, Font font) {
        this(word, font, 1);
    }

    public Word(String word, Font font, int swelling) {
        if (word == null || font == null) {
            throw new NullPointerException("Arguments cannot be null!");
        }
        this.word = word;
        this.font = font;
        this.weight = font.getSize();
        this.location = new Vector(0, 0);
        this.swelling = swelling;
        this.bbTree = null;
        //this.weight = weight;
        //Searched through source its always a general path.
        update();
    }

    public final void update() {
        templateShape = generateShape(word, font, weight);
        updateLocation();
        this.bbTree = BBTree.makeTree(shape, 0);
    }

    public boolean overlaps(Word other) {
        return bbTree.overlaps(other.bbTree);
    }

    public boolean overlaps(FinalizedWord other) {
        return bbTree.overlaps(other.getBBTree());
        //return shape.getBounds2D().intersects(other.getShape().getBounds2D());
    }

    @Override
    public int compareTo(Word o) {
        return Double.compare(weight, o.getWeight());
    }

    @Override
    public boolean equals(Object o) {
        return this.hashCode() == o.hashCode();
    }

    @Override
    public int hashCode() {
        int hash = 5;
        hash = 17 * hash + (this.word != null ? this.word.hashCode() : 0);
        hash = 17 * hash + (this.shape != null ? this.shape.hashCode() : 0);
        hash = 17 * hash + (int) (Double.doubleToLongBits(this.weight) ^ (Double.doubleToLongBits(this.weight) >>> 32));
        return hash;
    }

    public void updateLocation() {
        AffineTransform transform = AffineTransform.getTranslateInstance(location.getX(), location.getY());
        transform.rotate(Math.toRadians(orientation));
        shape = transform.createTransformedShape(templateShape);
        if (bbTree != null) {
            bbTree.setLocation((int) location.getX(), (int) location.getY());
        }
    }

    public FinalizedWord getFinalizedWord() {
        BBTree bbtree = BBTree.makeTree(shape, swelling);
        bbtree.setLocation((int) location.getX(), (int) location.getY());
        return new FinalizedWord(word, shape, bbtree);
    }
}

package wordielv2.generator;

import java.awt.Shape;
import lombok.AllArgsConstructor;
import lombok.Getter;

/**
 *
 * @author 17bbarker
 */
@AllArgsConstructor
public class FinalizedWord {

    @Getter
    private String word;
    @Getter
    private Shape shape;
    @Getter
    private BBTree bBTree;
    
        public boolean overlaps(FinalizedWord other) {
        return overlaps(other.getBBTree());
    }

    private boolean overlaps(BBTree bbtree) {
        if (bBTree == null) {
            return bBTree == bbtree;
        }
        return bBTree.overlaps(bbtree);
    }

    public boolean containsPoint(float x, float y) {
        if (bBTree == null) {
            return true;
        }
        return bBTree.containsPoint(x, y);
    }

}
